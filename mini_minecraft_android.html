<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Minecraft Abandoned House</title>
<style>
body{margin:0;overflow:hidden;background:#87ceeb;touch-action:none;font-family:sans-serif}
canvas{width:100%;height:100%;display:block}
#ui{position:absolute;inset:0;pointer-events:none;z-index:10}
.btn{pointer-events:auto;color:#fff;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.5);border:2px solid #fff;border-radius:10px;position:absolute;width:55px;height:55px;user-select:none}
#u{bottom:140px;left:75px} #d{bottom:20px;left:75px} #l{bottom:80px;left:15px} #r{bottom:80px;left:135px}
.act{position:absolute;width:70px;height:70px;border-radius:50%;background:rgba(255,255,255,0.2);border:2px solid #fff;pointer-events:auto;color:#fff;font-weight:bold}
#jmp{bottom:20px;right:105px} #put{bottom:100px;right:20px;background:rgba(76,175,80,.8)} #del{bottom:20px;right:20px;background:rgba(244,67,54,.8)}
#inv{position:absolute;top:10px;left:50%;transform:translateX(-50%);display:flex;gap:5px;background:rgba(0,0,0,.6);padding:6px;border-radius:8px;pointer-events:auto}
.slot{width:35px;height:35px;border:2px solid #555;background-size:cover}
.slot.active{border-color:#fff;box-shadow:0 0 10px #fff}
#fs-toggle{position:absolute;top:10px;right:10px;padding:12px;background:rgba(0,0,0,0.7);color:#fff;border:2px solid #fff;border-radius:8px;pointer-events:auto;font-size:12px;font-weight:bold}
</style>
</head>
<body>
<div id="ui">
    <div id="fs-toggle" onclick="toggleFS()">FULLSCREEN</div>
    <div id="inv">
        <div class="slot active" id="s1" onclick="sel(1,event)"></div>
        <div class="slot" id="s8" onclick="sel(8,event)"></div>
        <div class="slot" id="s9" onclick="sel(9,event)"></div> <div class="slot" id="s3" onclick="sel(3,event)"></div>
        <div class="slot" id="s4" onclick="sel(4,event)"></div>
    </div>
    <div class="btn" id="u">▲</div><div class="btn" id="d">▼</div>
    <div class="btn" id="l">◀</div><div class="btn" id="r">▶</div>
    <button class="act" id="jmp">JMP</button>
    <button class="act" id="put">PUT</button>
    <button class="act" id="del">DEL</button>
</div>

<script type="importmap">
{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js"}}
</script>

<script type="module">
import * as THREE from "three";

let scene, camera, renderer, yaw, pitch, ray;
let move = {f:0, b:0, l:0, r:0}, vel = 0, canJ = false, blocks = [], selected = 1;
const texs = {};

window.toggleFS = function() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(e => {
            alert(`Помилка: ${e.message}`);
        });
    } else {
        document.exitFullscreen();
    }
}

function mkTex(c1, c2, pattern='noise') {
    const can = document.createElement('canvas'); can.width = 16; can.height = 16;
    const ctx = can.getContext('2d');
    ctx.fillStyle = c1; ctx.fillRect(0,0,16,16);
    ctx.fillStyle = c2;
    if(pattern === 'planks') {
        ctx.fillRect(0, 7, 16, 2); ctx.fillRect(0, 15, 16, 1);
        ctx.fillRect(7, 0, 2, 7); ctx.fillRect(12, 8, 2, 7);
    } else if (pattern === 'brick') {
        for (let y = 0; y < 16; y += 4) {
            ctx.fillRect(0, y, 16, 1); // Горизонтальні лінії
        }
        for (let x = 0; x < 16; x += 8) {
            ctx.fillRect(x, 0, 1, 16); // Вертикальні лінії
        }
        for (let x = 4; x < 16; x += 8) {
            ctx.fillRect(x, 4, 1, 8); // Зміщення вертикальних ліній
        }
    } else {
        for(let i=0; i<32; i++) ctx.fillRect(Math.random()*16, Math.random()*16, 1, 1);
    }
    const t = new THREE.CanvasTexture(can); t.magFilter = THREE.NearestFilter; return t;
}

init();
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.fog = new THREE.Fog(0x87ceeb, 20, 70);

    texs[1] = mkTex('#5d8233', '#4a6929'); // трава
    texs[2] = mkTex('#795548', '#5d4037'); // земля
    texs[3] = mkTex('#808080', '#606060'); // камінь
    texs[4] = mkTex('#6d4c41', '#4e342e'); // колода
    texs[5] = mkTex('#1e88e5', '#1565c0'); // вода
    texs[6] = mkTex('#2e7d32', '#1b5e20'); // листя
    texs[7] = mkTex('#202020', '#000000'); // бедрок
    texs[8] = mkTex('#bc986a', '#967342', 'planks'); // дошки
    texs[9] = mkTex('#b53f3f', '#8c2f2f', 'brick'); // ЦЕГЛА

    const slots = [1, 8, 9, 3, 4]; // Додав цеглу в інвентар
    slots.forEach(id => {
        document.getElementById('s'+id).style.backgroundImage = `url(${texs[id].image.toDataURL()})`;
    });

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    pitch = new THREE.Object3D(); pitch.add(camera);
    yaw = new THREE.Object3D(); yaw.add(pitch);
    yaw.position.set(15, 10, 15); scene.add(yaw);

    renderer = new THREE.WebGLRenderer({antialias: false});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 1.4));
    ray = new THREE.Raycaster();

    createWorld();

    const b = (id, k) => {
        const el = document.getElementById(id);
        el.addEventListener('pointerdown', (e) => { e.preventDefault(); move[k] = 1; });
        el.addEventListener('pointerup', (e) => { e.preventDefault(); move[k] = 0; });
        el.addEventListener('pointerleave', () => { move[k] = 0; });
    };
    b("u","f"); b("d","b"); b("l","l"); b("r","r");

    document.getElementById("jmp").onpointerdown = (e) => { e.preventDefault(); if(canJ) vel = 0.22; };
    document.getElementById("put").onpointerdown = (e) => { e.preventDefault(); interact(true); };
    document.getElementById("del").onpointerdown = (e) => { e.preventDefault(); interact(false); };

    let lx, ly, isL = false;
    document.addEventListener("pointerdown", e => {
        if(e.target.closest(".btn") || e.target.closest(".act") || e.target.closest(".slot") || e.id === "fs-toggle") return;
        lx = e.clientX; ly = e.clientY; isL = true;
    });
    document.addEventListener("pointermove", e => {
        if (!isL) return;
        yaw.rotation.y -= (e.clientX - lx) * 0.006;
        pitch.rotation.x -= (e.clientY - ly) * 0.006;
        pitch.rotation.x = Math.max(-1.5, Math.min(1.5, pitch.rotation.x));
        lx = e.clientX; ly = e.clientY;
    });
    document.addEventListener("pointerup", () => isL = false);

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    loop();
}

function addB(x, y, z, t) {
    const mat = new THREE.MeshLambertMaterial({map: texs[t]});
    if(t === 5) { mat.transparent = true; mat.opacity = 0.6; }
    const m = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), mat);
    m.position.set(x, y, z); m.userData.type = t;
    scene.add(m); blocks.push(m);
}

function createWorld() {
    const WORLD_SIZE = 40;
    const LAKE_CENTER_X = WORLD_SIZE / 2;
    const LAKE_CENTER_Z = WORLD_SIZE / 2;
    const LAKE_RADIUS = 6;
    
    // Випадкова позиція для будинку
    const houseX = Math.floor(Math.random() * (WORLD_SIZE - 10)) + 5;
    const houseZ = Math.floor(Math.random() * (WORLD_SIZE - 10)) + 5;

    for(let x=0; x<WORLD_SIZE; x++) {
        for(let z=0; z<WORLD_SIZE; z++) {
            const distToLake = Math.sqrt((x-LAKE_CENTER_X)**2 + (z-LAKE_CENTER_Z)**2);
            
            if(distToLake < LAKE_RADIUS) { // ОЗЕРО В ЦЕНТРІ
                addB(x, 0, z, 5); // Вода
                addB(x, -1, z, 2); // Дно озера
            } else {
                addB(x, 0, z, 1); // Трава
                addB(x, -1, z, 2); // Земля
            }
            
            // Підземні шари
            for(let y=-2; y>-5; y--) addB(x, y, z, 3); // Камінь
            addB(x, -5, z, 7); // Бедрок
            
            // Дерева
            if(Math.random() > 0.98 && distToLake >= LAKE_RADIUS + 2 && x > 2 && x < WORLD_SIZE - 2 && z > 2 && z < WORLD_SIZE - 2) {
                for(let h=1; h<=3; h++) addB(x, h, z, 4);
                for(let lx=-1; lx<=1; lx++) for(let lz=-1; lz<=1; lz++) for(let ly=3; ly<=5; ly++) if(!(lx===0 && lz===0 && ly===3)) addB(x+lx, ly, z+lz, 6);
            }

            // ЗАКИНУТИЙ БУДИНОК (5x5x5 з цегли)
            if (x >= houseX && x < houseX + 5 && z >= houseZ && z < houseZ + 5) {
                for (let y = 1; y <= 5; y++) {
                    if (y === 5 || x === houseX || x === houseX + 4 || z === houseZ || z === houseZ + 4) { // Стіни та дах
                        if (Math.random() > 0.8 && y !== 5) continue; // "Поламані" стіни
                        if (Math.random() > 0.95 && y === 5) continue; // "Поламаний" дах
                        addB(x, y, z, 9); // Цегла
                    }
                }
                // Прохід у будинку (двері)
                if (x === houseX + 2 && z === houseZ && Math.random() < 0.3) { 
                    // Не завжди є двері, типу завалило
                } else if (x === houseX + 2 && z === houseZ && Math.random() > 0.7) { // Випадкове "вікно"
                    addB(x, 3, z, 9);
                } else if (x === houseX + 2 && z === houseZ + 4 && Math.random() < 0.5) { // Вікно з іншого боку
                    addB(x, 3, z, 9);
                }
            }
        }
    }
}

function interact(isP) {
    ray.setFromCamera({x:0, y:0}, camera);
    const h = ray.intersectObjects(blocks)[0];
    if(!h || h.distance > 5) return;
    if(isP) {
        const p = h.object.position.clone().add(h.face.normal);
        addB(p.x, p.y, p.z, selected);
    } else {
        if(h.object.userData.type !== 7) { 
            scene.remove(h.object);
            blocks = blocks.filter(o => o !== h.object);
        }
    }
}

window.sel = (i, e) => {
    selected = i;
    document.querySelectorAll(".slot").forEach(s => s.classList.remove('active'));
    e.target.classList.add('active');
};

function loop() {
    requestAnimationFrame(loop);
    vel -= 0.01;
    const oldP = yaw.position.clone();
    const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(yaw.quaternion);
    const rgt = new THREE.Vector3(1,0,0).applyQuaternion(yaw.quaternion);
    fwd.y = 0; rgt.y = 0; fwd.normalize(); rgt.normalize();

    if(move.f) yaw.position.add(fwd.multiplyScalar(0.12));
    if(move.b) yaw.position.add(fwd.multiplyScalar(-0.12));
    if(move.l) yaw.position.add(rgt.multiplyScalar(-0.12));
    if(move.r) yaw.position.add(rgt.multiplyScalar(0.12));

    let hit = false;
    for(let b of blocks) {
        if(b.userData.type === 5) continue; 
        if(Math.abs(yaw.position.x-b.position.x)<0.7 && Math.abs(yaw.position.z-b.position.z)<0.7 && Math.abs(yaw.position.y-1-b.position.y)<1) hit = true;
    }
    if(hit) yaw.position.copy(oldP);

    yaw.position.y += vel;
    let floor = false;
    for(let b of blocks) {
        if(b.userData.type === 5) continue; 
        if(Math.abs(yaw.position.x-b.position.x)<0.6 && Math.abs(yaw.position.z-b.position.z)<0.6 && Math.abs(yaw.position.y-1.8-b.position.y)<0.2) floor = true;
    }
    if(floor) { yaw.position.y = oldP.y; vel = 0; canJ = true; } else { canJ = false; }
    renderer.render(scene, camera);
}
</script>
</body>
</html>







