<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minecraft Mobile - Easy Move</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87ceeb; touch-action: none; font-family: sans-serif; user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .touch-btn { position: absolute; background: rgba(0,0,0,0.5); border: 2px solid #fff; border-radius: 8px; pointer-events: auto; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; width: 60px; height: 60px; -webkit-user-drag: none; }
        #btn-up { bottom: 140px; left: 90px; }
        #btn-down { bottom: 20px; left: 90px; }
        #btn-left { bottom: 80px; left: 20px; }
        #btn-right { bottom: 80px; left: 160px; }
        .action-btn { position: absolute; border-radius: 50%; border: 2px solid white; pointer-events: auto; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; }
        #btn-jump { bottom: 40px; right: 140px; width: 75px; height: 75px; background: rgba(255,255,255,0.2); }
        #btn-build { bottom: 120px; right: 30px; width: 85px; height: 85px; background: rgba(76, 175, 80, 0.8); }
        #btn-destroy { bottom: 20px; right: 30px; width: 85px; height: 85px; background: rgba(244, 67, 54, 0.8); }
        #inventory { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; pointer-events: auto; background: rgba(0,0,0,0.6); padding: 8px; border-radius: 10px; }
        .slot { width: 42px; height: 42px; border: 2px solid #444; background-size: cover; border-radius: 4px; }
        .slot.active { border-color: #fff; box-shadow: 0 0 10px #fff; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 12px; height: 12px; border: 2px solid white; transform: translate(-50%, -50%); border-radius: 50%; opacity: 0.6; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="crosshair"></div>
    <div id="inventory">
        <div class="slot active" id="s1" onclick="window.setBlock(1)"></div>
        <div class="slot" id="s4" onclick="window.setBlock(4)"></div>
        <div class="slot" id="s6" onclick="window.setBlock(6)"></div>
        <div class="slot" id="s3" onclick="window.setBlock(3)"></div>
        <div class="slot" id="s5" onclick="window.setBlock(5)"></div>
    </div>
    <div class="touch-btn" id="btn-up">↑</div>
    <div class="touch-btn" id="btn-down">↓</div>
    <div class="touch-btn" id="btn-left">←</div>
    <div class="touch-btn" id="btn-right">→</div>
    <div class="action-btn" id="btn-build">+</div>
    <div class="action-btn" id="btn-destroy">−</div>
    <div class="action-btn" id="btn-jump">UP</div>
</div>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
    import * as THREE from 'three';

    let scene, camera, renderer, yawObj, pitchObj, raycaster;
    let move = { f: 0, b: 0, l: 0, r: 0 };
    let velocity = new THREE.Vector3(0, 0, 0);
    let canJump = false;
    let objects = [];
    let selectedBlock = 1, lastTouchX = 0, lastTouchY = 0;
    
    const textures = {};

    function createTex(color, noiseColor) {
        const canvas = document.createElement('canvas');
        canvas.width = 16; canvas.height = 16;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = color; ctx.fillRect(0,0,16,16);
        ctx.fillStyle = noiseColor;
        for(let i=0; i<32; i++) ctx.fillRect(Math.random()*16, Math.random()*16, 2, 2);
        const tex = new THREE.CanvasTexture(canvas);
        tex.magFilter = THREE.NearestFilter;
        return tex;
    }

    init();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 15, 50);

        textures[1] = createTex('#5d8233', '#4d6d2a');
        textures[2] = createTex('#795548', '#614126');
        textures[3] = createTex('#808080', '#696969');
        textures[4] = createTex('#614126', '#4e341e');
        textures[5] = createTex('#1e88e5', '#1976d2');
        textures[6] = createTex('#2e7d32', '#1b5e20');

        [1, 4, 6, 3, 5].forEach(id => {
            document.getElementById('s'+id).style.backgroundImage = `url(${textures[id].image.toDataURL()})`;
        });

        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        pitchObj = new THREE.Object3D(); pitchObj.add(camera);
        yawObj = new THREE.Object3D(); yawObj.add(pitchObj);
        
        // Початкова позиція (вище над землею)
        yawObj.position.set(5, 10, 5); 
        scene.add(yawObj);

        renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        scene.add(new THREE.AmbientLight(0xffffff, 1.5));
        raycaster = new THREE.Raycaster();
        
        generateWorld();
        loop();

        // Покращене керування
        const setM = (id, k, v) => {
            const el = document.getElementById(id);
            el.addEventListener('touchstart', (e) => { e.preventDefault(); move[k] = v; });
            el.addEventListener('touchend', (e) => { e.preventDefault(); move[k] = 0; });
        };
        setM('btn-up','f',1); setM('btn-down','b',1); setM('btn-left','l',1); setM('btn-right','r',1);

        document.getElementById('btn-jump').addEventListener('touchstart', (e) => { 
            e.preventDefault(); if(canJump) velocity.y = 0.22; 
        });
        document.getElementById('btn-build').addEventListener('touchstart', (e) => { e.preventDefault(); interact(true); });
        document.getElementById('btn-destroy').addEventListener('touchstart', (e) => { e.preventDefault(); interact(false); });

        document.addEventListener('touchstart', (e) => {
            if (e.target.closest('.touch-btn') || e.target.closest('.action-btn') || e.target.closest('.slot')) return;
            lastTouchX = e.touches[0].clientX; lastTouchY = e.touches[0].clientY;
        });

        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('.touch-btn') || e.target.closest('.action-btn')) return;
            const dx = e.touches[0].clientX - lastTouchX;
            const dy = e.touches[0].clientY - lastTouchY;
            yawObj.rotation.y -= dx * 0.007;
            pitchObj.rotation.x -= dy * 0.007;
            pitchObj.rotation.x = Math.max(-1.5, Math.min(1.5, pitchObj.rotation.x));
            lastTouchX = e.touches[0].clientX; lastTouchY = e.touches[0].clientY;
        }, { passive: false });

        window.setBlock = (id) => { 
            selectedBlock = id; 
            document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
            document.getElementById('s'+id).classList.add('active');
        };
    }

    function addBlock(x, y, z, type) {
        const mat = new THREE.MeshLambertMaterial({ map: textures[type], transparent: type===5, opacity: type===5?0.6:1 });
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat);
        mesh.position.set(x, y, z);
        mesh.userData.type = type;
        scene.add(mesh);
        if(type !== 5) objects.push(mesh);
    }

    function generateWorld() {
        for(let x=0; x<25; x++) {
            for(let z=0; z<25; z++) {
                addBlock(x, -1, z, 2); // Земля
                addBlock(x, 0, z, 1);  // Трава
                if(Math.random() > 0.97) { // Рідкі дерева
                    for(let i=1; i<=3; i++) addBlock(x, i, z, 4);
                    addBlock(x, 4, z, 6);
                }
            }
        }
    }

    function interact(place) {
        raycaster.setFromCamera({x: 0, y: 0}, camera);
        const hits = raycaster.intersectObjects(scene.children);
        const bHits = hits.filter(h => h.object.geometry && h.object.geometry.type === "BoxGeometry");
        if(bHits.length > 0 && bHits[0].distance < 5) {
            const h = bHits[0];
            if(place) {
                const p = h.object.position.clone().add(h.face.normal);
                addBlock(p.x, p.y, p.z, selectedBlock);
            } else {
                if(h.object.position.y <= 0) return;
                scene.remove(h.object);
                objects = objects.filter(o => o !== h.object);
            }
        }
    }

    function loop() {
        requestAnimationFrame(loop);
        
        // Гравітація
        velocity.y -= 0.012;
        yawObj.position.y += velocity.y;

        // Колізія по вертикалі (підлога)
        canJump = false;
        if (yawObj.position.y < 1.7) {
            yawObj.position.y = 1.7;
            velocity.y = 0;
            canJump = true;
        }

        // Рух
        let speed = 0.12;
        let dirX = (move.r - move.l);
        let dirZ = (move.b - move.f);
        
        if (dirX !== 0 || dirZ !== 0) {
            const angle = yawObj.rotation.y;
            const moveVec = new THREE.Vector3(dirX, 0, dirZ).normalize();
            moveVec.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
            
            yawObj.position.x += moveVec.x * speed;
            yawObj.position.z += moveVec.z * speed;
        }

        renderer.render(scene, camera);
    }
</script>
</body>
</html>






