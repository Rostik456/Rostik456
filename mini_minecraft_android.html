<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minecraft Fixed Control</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87ceeb; touch-action: none; font-family: sans-serif; user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Кнопки керування */
        .btn { 
            position: absolute; background: rgba(0,0,0,0.4); border: 2px solid #fff; 
            border-radius: 10px; pointer-events: auto; display: flex; 
            align-items: center; justify-content: center; color: white; font-size: 24px;
            width: 65px; height: 65px; active-background: rgba(255,255,255,0.4);
        }
        .btn:active { background: rgba(255,255,255,0.4); transform: scale(0.95); }
        
        #up { bottom: 150px; left: 95px; }
        #down { bottom: 20px; left: 95px; }
        #left { bottom: 85px; left: 20px; }
        #right { bottom: 85px; left: 170px; }
        
        .act { position: absolute; border-radius: 50%; border: 2px solid white; pointer-events: auto; color: white; display: flex; align-items: center; justify-content: center; }
        #jump { bottom: 40px; right: 140px; width: 80px; height: 80px; background: rgba(255,255,255,0.2); }
        #build { bottom: 130px; right: 30px; width: 90px; height: 90px; background: rgba(76, 175, 80, 0.7); }
        #kill { bottom: 20px; right: 30px; width: 90px; height: 90px; background: rgba(244, 67, 54, 0.7); }

        #inv { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; pointer-events: auto; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 12px; }
        .slot { width: 45px; height: 45px; border: 2px solid #555; background-size: cover; border-radius: 5px; }
        .slot.active { border-color: #fff; box-shadow: 0 0 15px #fff; }
        #cross { position: absolute; top: 50%; left: 50%; width: 15px; height: 15px; border: 2px solid white; transform: translate(-50%, -50%); border-radius: 50%; opacity: 0.5; }
    </style>
</head>
<body>

<div id="ui">
    <div id="cross"></div>
    <div id="inv">
        <div class="slot active" id="i1" onclick="window.setB(1)"></div>
        <div class="slot" id="i4" onclick="window.setB(4)"></div>
        <div class="slot" id="i6" onclick="window.setB(6)"></div>
        <div class="slot" id="i3" onclick="window.setB(3)"></div>
        <div class="slot" id="i5" onclick="window.setB(5)"></div>
    </div>
    <div class="btn" id="up">↑</div><div class="btn" id="down">↓</div>
    <div class="btn" id="left">←</div><div class="btn" id="right">→</div>
    <div class="act" id="jump">JUMP</div>
    <div class="act" id="build">BUILD</div>
    <div class="act" id="kill">KILL</div>
</div>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
    import * as THREE from 'three';

    let scene, camera, renderer, yaw, pitch, ray;
    let move = { f: 0, b: 0, l: 0, r: 0 };
    let vel = new THREE.Vector3();
    let objects = [];
    let selB = 1, lastTX = 0, lastTY = 0;
    const texs = {};

    function mkTex(c1, c2) {
        const can = document.createElement('canvas'); can.width = 16; can.height = 16;
        const ctx = can.getContext('2d');
        ctx.fillStyle = c1; ctx.fillRect(0,0,16,16);
        ctx.fillStyle = c2; for(let i=0; i<30; i++) ctx.fillRect(Math.random()*16, Math.random()*16, 2, 2);
        const t = new THREE.CanvasTexture(can); t.magFilter = THREE.NearestFilter; return t;
    }

    init();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        
        texs[1] = mkTex('#5d8233', '#4d6d2a'); texs[2] = mkTex('#795548', '#614126');
        texs[3] = mkTex('#808080', '#696969'); texs[4] = mkTex('#614126', '#4e341e');
        texs[5] = mkTex('#1e88e5', '#1976d2'); texs[6] = mkTex('#2e7d32', '#1b5e20');

        [1, 4, 6, 3, 5].forEach(id => document.getElementById('i'+id).style.backgroundImage = `url(${texs[id].image.toDataURL()})`);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 500);
        pitch = new THREE.Object3D(); pitch.add(camera);
        yaw = new THREE.Object3D(); yaw.add(pitch);
        yaw.position.set(12, 5, 12); scene.add(yaw);

        renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 1.5));
        ray = new THREE.Raycaster();

        // Генеруємо карту
        for(let x=0; x<25; x++) {
            for(let z=0; z<25; z++) {
                addB(x, 0, z, 1);
                if(Math.random() > 0.98) { for(let i=1; i<4; i++) addB(x, i, z, 4); addB(x, 4, z, 6); }
            }
        }

        // Обробка кнопок (виправлено для Android)
        const bind = (id, k) => {
            const el = document.getElementById(id);
            el.addEventListener('touchstart', (e) => { e.preventDefault(); move[k] = 1; }, {passive: false});
            el.addEventListener('touchend', (e) => { e.preventDefault(); move[k] = 0; }, {passive: false});
        };
        bind('up', 'f'); bind('down', 'b'); bind('left', 'l'); bind('right', 'r');

        document.getElementById('jump').addEventListener('touchstart', (e) => { e.preventDefault(); vel.y = 0.2; });
        document.getElementById('build').addEventListener('touchstart', (e) => { e.preventDefault(); interact(true); });
        document.getElementById('kill').addEventListener('touchstart', (e) => { e.preventDefault(); interact(false); });

        // Огляд пальцем
        document.addEventListener('touchstart', e => { if(e.target.tagName !== 'DIV') return; lastTX = e.touches[0].clientX; lastTY = e.touches[0].clientY; });
        document.addEventListener('touchmove', e => {
            if(e.target.className.includes('btn') || e.target.className.includes('act')) return;
            yaw.rotation.y -= (e.touches[0].clientX - lastTX) * 0.008;
            pitch.rotation.x -= (e.touches[0].clientY - lastTY) * 0.008;
            pitch.rotation.x = Math.max(-1.5, Math.min(1.5, pitch.rotation.x));
            lastTX = e.touches[0].clientX; lastTY = e.touches[0].clientY;
        }, { passive: false });

        window.setB = (id) => { selB = id; document.querySelectorAll('.slot').forEach(s => s.classList.remove('active')); document.getElementById('i'+id).classList.add('active'); };
        
        loop();
    }

    function addB(x, y, z, t) {
        const m = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshLambertMaterial({map: texs[t], transparent: t===5, opacity: t===5?0.6:1}));
        m.position.set(x, y, z); scene.add(m); objects.push(m);
    }

    function interact(p) {
        ray.setFromCamera({x:0, y:0}, camera);
        const h = ray.intersectObjects(objects);
        if(h.length > 0 && h[0].distance < 5) {
            if(p) { const pos = h[0].object.position.clone().add(h[0].face.normal); addB(pos.x, pos.y, pos.z, selB); }
            else { if(h[0].object.position.y > 0) { scene.remove(h[0].object); objects = objects.filter(o => o !== h[0].object); } }
        }
    }

    function loop() {
        requestAnimationFrame(loop);
        
        // Спрощена гравітація (щоб не провалюватись)
        vel.y -= 0.01;
        yaw.position.y += vel.y;
        if(yaw.position.y < 1.8) { yaw.position.y = 1.8; vel.y = 0; }

        // Рух
        const speed = 0.12;
        const forward = new THREE.Vector3(0,0,-1).applyQuaternion(yaw.quaternion);
        const right = new THREE.Vector3(1,0,0).applyQuaternion(yaw.quaternion);
        
        if(move.f) yaw.position.add(forward.multiplyScalar(speed));
        if(move.b) yaw.position.add(forward.multiplyScalar(-speed));
        if(move.l) yaw.position.add(right.multiplyScalar(-speed));
        if(move.r) yaw.position.add(right.multiplyScalar(speed));

        renderer.render(scene, camera);
    }
</script>
</body>
</html>






