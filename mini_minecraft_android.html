<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minecraft Mobile - Full World View</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87ceeb; touch-action: none; font-family: sans-serif; user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .touch-btn { position: absolute; background: rgba(0,0,0,0.4); border: 2px solid rgba(255,255,255,0.5); border-radius: 8px; pointer-events: auto; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; }
        #btn-up { bottom: 130px; left: 85px; width: 55px; height: 55px; }
        #btn-down { bottom: 20px; left: 85px; width: 55px; height: 55px; }
        #btn-left { bottom: 75px; left: 20px; width: 55px; height: 55px; }
        #btn-right { bottom: 75px; left: 150px; width: 55px; height: 55px; }
        .action-btn { position: absolute; border-radius: 50%; border: 2px solid white; pointer-events: auto; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 12px; }
        #btn-jump { bottom: 30px; right: 130px; width: 70px; height: 70px; background: rgba(255,255,255,0.2); }
        #btn-build { bottom: 110px; right: 30px; width: 80px; height: 80px; background: rgba(76, 175, 80, 0.7); }
        #btn-destroy { bottom: 20px; right: 30px; width: 80px; height: 80px; background: rgba(244, 67, 54, 0.7); }
        #inventory { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; pointer-events: auto; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 10px; }
        .slot { width: 40px; height: 40px; border: 2px solid #444; border-radius: 4px; display: flex; align-items: center; justify-content: center; }
        .slot.active { border-color: #fff; box-shadow: 0 0 10px #fff; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 14px; height: 14px; border: 2px solid white; transform: translate(-50%, -50%); border-radius: 50%; opacity: 0.8; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="crosshair"></div>
    <div id="inventory">
        <div class="slot active" onclick="window.setBlock(1)"><div style="width:25px;height:25px;background:#5d8233"></div></div>
        <div class="slot" onclick="window.setBlock(4)"><div style="width:25px;height:25px;background:#614126"></div></div>
        <div class="slot" onclick="window.setBlock(6)"><div style="width:25px;height:25px;background:#2e7d32"></div></div>
        <div class="slot" onclick="window.setBlock(3)"><div style="width:25px;height:25px;background:#808080"></div></div>
        <div class="slot" onclick="window.setBlock(5)"><div style="width:25px;height:25px;background:#1e88e5"></div></div>
    </div>
    <div class="touch-btn" id="btn-up">W</div><div class="touch-btn" id="btn-down">S</div>
    <div class="touch-btn" id="btn-left">A</div><div class="touch-btn" id="btn-right">D</div>
    <div class="action-btn" id="btn-build">BUILD</div>
    <div class="action-btn" id="btn-destroy">KILL</div>
    <div class="action-btn" id="btn-jump">JUMP</div>
</div>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
    import * as THREE from 'three';

    let scene, camera, renderer, yawObj, pitchObj, raycaster;
    let move = { f: 0, b: 0, l: 0, r: 0 };
    let velocity = new THREE.Vector3(0, 0, 0);
    let canJump = false, isInWater = false;
    let objects = [], pigs = [];
    let selectedBlock = 1, lastTouchX = 0, lastTouchY = 0;

    const mapSize = 50;
    const playerHeight = 1.7;
    const blockColors = { 1: 0x5d8233, 2: 0x795548, 3: 0x808080, 4: 0x614126, 5: 0x1e88e5, 6: 0x2e7d32, 7: 0xffffff };

    init();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        // ЗБІЛЬШЕНО ТУМАН (щоб бачити далі)
        scene.fog = new THREE.Fog(0x87ceeb, 30, 80);
        
        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        pitchObj = new THREE.Object3D(); pitchObj.add(camera);
        yawObj = new THREE.Object3D(); yawObj.add(pitchObj);
        
        // ФІКСОВАННИЙ СПАВН
        yawObj.position.set(10, 5, 10); 
        scene.add(yawObj);

        renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio > 1 ? 1.5 : 1); // Оптимізація
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 1.2));
        let sun = new THREE.DirectionalLight(0xffffff, 0.5);
        sun.position.set(10, 50, 10);
        scene.add(sun);

        raycaster = new THREE.Raycaster();

        generateWorld();
        for(let i=0; i<6; i++) createPig(15 + Math.random()*20, 1, 15 + Math.random()*20);

        // Керування
        const setupBtn = (id, key) => {
            const el = document.getElementById(id);
            el.addEventListener('touchstart', (e) => { e.preventDefault(); move[key] = 1; });
            el.addEventListener('touchend', (e) => { e.preventDefault(); move[key] = 0; });
        };
        setupBtn('btn-up', 'f'); setupBtn('btn-down', 'b');
        setupBtn('btn-left', 'l'); setupBtn('btn-right', 'r');

        document.getElementById('btn-jump').addEventListener('touchstart', () => { if(canJump || isInWater) velocity.y = 0.22; });
        document.getElementById('btn-build').addEventListener('touchstart', () => interact(true));
        document.getElementById('btn-destroy').addEventListener('touchstart', () => interact(false));

        document.addEventListener('touchstart', (e) => {
            if (e.target.closest('.touch-btn') || e.target.closest('.action-btn') || e.target.closest('.slot')) return;
            lastTouchX = e.touches[0].clientX; lastTouchY = e.touches[0].clientY;
        });
        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('.touch-btn') || e.target.closest('.action-btn')) return;
            let dx = e.touches[0].clientX - lastTouchX;
            let dy = e.touches[0].clientY - lastTouchY;
            yawObj.rotation.y -= dx * 0.005; pitchObj.rotation.x -= dy * 0.005;
            pitchObj.rotation.x = Math.max(-1.5, Math.min(1.5, pitchObj.rotation.x));
            lastTouchX = e.touches[0].clientX; lastTouchY = e.touches[0].clientY;
        }, { passive: false });

        window.setBlock = (id) => { 
            selectedBlock = id; 
            document.querySelectorAll('.slot').forEach((s, i) => {
                const map = [1, 4, 6, 3, 5];
                s.classList.toggle('active', map[i] === id);
            });
        };

        loop();
    }

    function addBlock(x, y, z, type, collidable = true) {
        const mat = new THREE.MeshLambertMaterial({ 
            color: blockColors[type], 
            transparent: type===5, 
            opacity: type===5?0.6:1 
        });
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), mat);
        mesh.position.set(Math.floor(x), Math.floor(y), Math.floor(z));
        mesh.userData.type = type;
        mesh.userData.collidable = collidable;
        scene.add(mesh); 
        if(collidable) objects.push(mesh);
    }

    function generateWorld() {
        for(let x=0; x<mapSize; x++) {
            for(let z=0; z<mapSize; z++) {
                const dist = Math.sqrt((x-25)**2 + (z-25)**2);
                if (dist < 8) { 
                    addBlock(x, -1, z, 3); addBlock(x, 0, z, 5, false); // Озеро (без колізії)
                } else { 
                    addBlock(x, -1, z, 2); addBlock(x, 0, z, 1); // Земля та Трава
                    if (Math.random() > 0.985 && dist > 10) { // Дерева
                        let h = 3;
                        for(let i=1; i<=h; i++) addBlock(x, i, z, 4);
                        for(let lx=-1; lx<=1; lx++) for(let lz=-1; lz<=1; lz++) addBlock(x+lx, h+1, z+lz, 6);
                        addBlock(x, h+2, z, 6);
                    }
                }
                // ДОДАНО ХМАРИ
                if (Math.random() > 0.995) {
                    for(let cx=0; cx<3; cx++) addBlock(x+cx, 15 + Math.random()*2, z, 7, false);
                }
            }
        }
    }

    function createPig(x, y, z) {
        const group = new THREE.Group();
        const mat = new THREE.MeshLambertMaterial({color: 0xffadc7});
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.5, 0.9), mat); body.position.y = 0.5;
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), mat); head.position.set(0, 0.7, 0.5);
        group.add(body, head); group.position.set(x, y, z);
        scene.add(group);
        pigs.push({ mesh: group, dir: new THREE.Vector3(1, 0, 0), timer: 0, targetRot: 0 });
    }

    function checkColl(pos) {
        isInWater = false;
        for(let obj of objects) {
            if(!obj.userData.collidable) continue;
            let dx = Math.abs(pos.x - obj.position.x), dy = Math.abs((pos.y - playerHeight/2) - obj.position.y), dz = Math.abs(pos.z - obj.position.z);
            if(dx < 0.7 && dz < 0.7 && dy < 1.2) return true;
        }
        // Перевірка на воду окремо (вона в сцені, але не в масиві objects для колізій)
        const centerDist = Math.sqrt((pos.x-25)**2 + (pos.z-25)**2);
        if(centerDist < 8.5 && pos.y < 1.5) isInWater = true;
        return false;
    }

    function interact(isPlace) {
        raycaster.setFromCamera({x: 0, y: 0}, camera);
        const hits = raycaster.intersectObjects(scene.children);
        const blockHits = hits.filter(h => h.object.geometry && h.object.geometry.type === "BoxGeometry");
        if (blockHits.length > 0 && blockHits[0].distance < 5) {
            const hitObj = blockHits[0].object;
            if (isPlace) { 
                const p = hitObj.position.clone().add(blockHits[0].face.normal);
                addBlock(p.x, p.y, p.z, selectedBlock); 
            } else { 
                if(hitObj.position.y <= -1) return;
                scene.remove(hitObj); 
                objects = objects.filter(o => o !== hitObj); 
            }
        }
    }

    function loop() {
        requestAnimationFrame(loop);
        let oldP = yawObj.position.clone();
        velocity.y -= isInWater ? 0.005 : 0.01;
        let speed = isInWater ? 0.07 : 0.13;
        let mv = new THREE.Vector3(move.r-move.l, 0, move.b-move.f).applyQuaternion(yawObj.quaternion).normalize().multiplyScalar(speed);
        
        yawObj.position.x += mv.x; if(checkColl(yawObj.position)) yawObj.position.x = oldP.x;
        yawObj.position.z += mv.z; if(checkColl(yawObj.position)) yawObj.position.z = oldP.z;
        yawObj.position.y += velocity.y;
        if(checkColl(yawObj.position)) { if(velocity.y < 0) canJump = true; yawObj.position.y = oldP.y; velocity.y = 0; }

        pigs.forEach(pig => {
            pig.timer--;
            if(pig.timer <= 0) {
                pig.dir.set(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                pig.targetRot = Math.atan2(pig.dir.x, pig.dir.z);
                pig.timer = 150 + Math.random()*200;
            }
            let angleDiff = pig.targetRot - pig.mesh.rotation.y;
            while(angleDiff < -Math.PI) angleDiff += Math.PI*2;
            while(angleDiff > Math.PI) angleDiff -= Math.PI*2;
            pig.mesh.rotation.y += angleDiff * 0.04;
            let pOld = pig.mesh.position.clone();
            pig.mesh.position.add(pig.dir.clone().multiplyScalar(0.025));
            let d = Math.sqrt((pig.mesh.position.x-25)**2 + (pig.mesh.position.z-25)**2);
            if(d < 9 || pig.mesh.position.x<2 || pig.mesh.position.x>48 || pig.mesh.position.z<2 || pig.mesh.position.z>48) {
                pig.mesh.position.copy(pOld); pig.timer = 0;
            }
        });

        renderer.render(scene, camera);
    }
</script>
</body>
</html>





